string使用：
string s1();  // si = ""
string s2("Hello");  // s2 = "Hello"
string s3(4, 'K');  // s3 = "KKKK"
string s4("12345", 1, 3);  //s4 = "234"，即 "12345" 的从下标 1 开始，长度为 3 的子串

string str="123";
for (auto ch : str)

1.在字符串末尾添加一个字符
a.push_back('3'); //结果为 a="1233";

2.在字符串末尾删除一个字符
a.pop_back(); //结果为 a="12";


vector的截取片段：
vector<int>::const_iterator left = nums.begin();
vector<int>::const_iterator right = nums.begin()+len;
vector<int> temp(left,right);
vector <int> vec(10,90); //将10个一维动态数组初始为90
vector<int> ilist4(7);//默认值初始化，list 中将包含7个元素，每个元素进行缺省的值初始化。对于int，也就是被赋值为0
vector<vector<int>> vec(row,vector<int>(col,0)); //初始化row 行 col列二维动态数组，初始化值为0

g++ hello.cpp -o hello
./hello


webserver项目地址：https://github.com/imarvinle/WebServer
http状态解析教程：https://blog.csdn.net/weixin_43327696/article/details/106238866


#include<string.h>
char*  strpbrk(char* str1,char* str2)
返回在str1中的第一个在str2中出现的字符的地址。
C 库函数 char *strpbrk(const char *str1, const char *str2) 检索字符串 str1 中第一个匹配字符串 str2 中字符的字符，不包含空结束字符。也就是说，依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置。

#include<strings.h>(不是C/C++标准头文件，区别于string.h)
int strcasecmp(const char *s1, const char *s2);//不区分大小写
strcasecmp函数是二进制且对大小写不敏感。此函数只在Linux中提供，相当于windows平台的 stricmp。
若参数s1和s2字符串相等返回0，s1大于s2则返回大于0的值，s1小于s2则返回小于0的值。


C 库函数 size_t strspn(const char *str1, const char *str2) 检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。


deque <int>  双端队列
bool empty()
判断deque容器是否已有元素，空返回1 （true），非空返回0 。

queue 和 stack 有一些成员函数相似，但在一些情况下，工作方式有些不同：
front()：返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。
back()：返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。
push(const T& obj)：在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。
push(T&& obj)：以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。
pop()：删除 queue 中的第一个元素。
size()：返回 queue 中元素的个数。
empty()：如果 queue 中没有元素的话，返回 true。
emplace()：用传给 emplace() 的参数调用 T 的构造函数，在 queue 的尾部生成对象。
swap(queue<T> &other_q)：将当前 queue 中的元素和参数 queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。

const int *p1;//p1、p2本身可以改变，但是指向 的数据不能修改
int const *p2;
int * const p3;//p3本身不能修改，但是里面指向 的值可以修改
const int * const p4;
int const * const p5;//p4、p5是两者都不能修改


01背包问题：
01背包问题：每个物品不能重复
完全背包问题：每个物品可以重复
多重背包问题

int-> -2147483648——2147483647

c语言编译文件的四个步骤：
1.预处理：将所有的#include头文件以及宏定义替换成其真正的内容，预处理之后得到的仍然是文本文件，也就是说将include中的内容展开到文件中
2.编译：语法分析、代码优化、将上一步产生的文件转换成特定的汇编代码。生成的也是一个文本文件（汇编代码文件）
3.汇编：将上一步的汇编代码转换成机器码(machine code)。
4.链接：将多个目标文以及所需的库文件(.so等)链接成最终的可执行文件(executable file)。

extern在c语言中的作用：在变量没有定义之前先声明它，可以预先使用，但是变量的地址分配不在这里，
extern“c' 一旦被 extern "C" 修饰之后，它便以 C 的方式工作（编译阶段：以C的方式编译，链接阶段：寻找C方式编译生成的符号）,实现c/c++的混合编程，c和c++ 对函数的编译方式不一样的。
c++支持函数重载，c语言不支持，ex: void foo(int x,int y);
在c编译器中，名字是_foo,而在c++编译器中名字是像_foo_int_int之类的名字用来支持函数重载和类型安全连接。

C++结构体和C结构体的区别？
C++ 的结构体中允许有函数并且可以是虚函数，c中的结构体不允许有函数。

static：
1.静态变量、静态函数的作用域是本源文件。
2.C++规定静态成员函数没有this指针（划重点，面试题常考）。

32位操作系统下，指针大小是4，64位下，指针大小是8.

函数指针就是指向函数的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。
int func(int a);  
int (*f)(int a);  //声明
f = &func; //赋值
cout<<(*f)(2);//使用

全局（静态）存储区：分为DATA区（初始化的全局变量和静态变量）
和BSS段（未初始化的全局变量和静态变量，BSS段会在程序执行之前系统自动清0）

i++和++i的源代前置(++i)自增，先自增，后返回原对象的对象；没有产生任何临时对象；而后置(i++)自增，先保存原对象，然后自增，最后返回该原临时对象

1\malloc在参数为0的情况返回的不是nullptr、申请失败(可用空间不足)的时候返回的是nullptr
malloc实际分配的内存会大于我们需要的size。因为1.字节对齐。2、“块头部信息”，每个空闲块都有“头部”控制信息，其中包含一个指向链表中下一个块的指针、当前块的大小和一个指向本身的指针。为了简化块对齐，所有块的大小都必须是头部大小的整数倍，且头部已正确对齐。
malloc/free的实现过程：
1、空闲存储空间以空闲链表的方式组织（地址递增），每个块包含一个长度、一个指向下一块的指针以及一个指向自身存储空间的指针。（ 因为程序中的某些地方可能不通过malloc调用申请，因此malloc管理的空间不一定连续。）
2、当有申请请求时，malloc会扫描空闲链表，直到找到一个足够大的块为止（首次适应）(因此每次调用malloc时并不是花费了完全相同的时间）。
3、如果该块恰好与请求的大小相符，则将其从链表中移走并返回给用户。如果该块太大，则将其分为两部分，尾部的部分分给用户，剩下的部分留在空闲链表中（更改头部信息）。因此malloc分配的是一块连续的内存。
4、释放时，首先搜索空闲链表，找到可以插入被释放块的合适位置。如果与被释放块相邻的任一边是一个空闲块，则将这两个块合为一个更大的块，以减少内存碎片。
2\new一般，在 new 一个对象的时候，底层做了一下两步：
1.为对象分配内存；
2.调用构造函数初始化这块内存；
placement new的作用是在一块已经申请好的内存上构造一个对象。具体就是在调用placement new之前，已经有一块内存已经申请好了，我们只需要在这块内存上直接进行构造就可以了。
ex：char *p = new char[sizeof(Test)];
      Test *pTest = new(p) Test;